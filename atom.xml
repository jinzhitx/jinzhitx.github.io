<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>禁止通行</title>
  
  <subtitle>卑以自牧 剑胆琴心</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-11T11:13:53.943Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>keanu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机层次和编程语言运行机制</title>
    <link href="http://example.com/2021/03/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/03/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2021-03-11T04:50:36.000Z</published>
    <updated>2021-03-11T11:13:53.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h1><h2 id="实际机器（物理设备）"><a href="#实际机器（物理设备）" class="headerlink" title="实际机器（物理设备）"></a>实际机器（物理设备）</h2><p><strong>硬件逻辑层</strong><br>    门，触发器等逻辑电路组成<br>    属于电子工程的领域<br><strong>微程序机器层</strong><br>    编程语言是微指令集<br>    微指令所组成的微程序(机器指令)直接交由硬件执行<br><strong>传统机器曾</strong><br>    编程语言是CPU指令集（机器指令<br>    编程语言和硬件是直接相关<br>    不同架构的CPU使用不同的CPU指令集</p><h2 id="虚拟机器"><a href="#虚拟机器" class="headerlink" title="虚拟机器"></a>虚拟机器</h2><p><strong>系统软件</strong><br>·操作系统层<br>    向上提供了简易的操作界面<br>    向下对接了指令系统，管理硬件资源<br>    操作系统层是软件和硬件之间的适配层<br>·汇编语言层<br>    编程语言是汇编语言<br>    汇编语言可以翻译成可直接执行的机器语言<br>    完成翻译的过程的程序就是汇编曾<br>·高级语言层<br>    编程语言为广大程序员所接受<br>    高级语言的类别非常多，由几百<br>    常见的高级语言有：Python，java,C/C++,Golang等<br><strong>应用层</strong><br>    满足计算机针对某种用途而专门设计</p><h1 id="程序翻译和程序解释"><a href="#程序翻译和程序解释" class="headerlink" title="程序翻译和程序解释"></a>程序翻译和程序解释</h1><pre><code>编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。这只是表象，二者背后的最大区别是：对解释执行而言，程序运行时的控制权在解释器而不在用户程序；对编译执行而言，运行时的控制权在用户程序。 </code></pre><p><strong>编译器</strong>是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快;<br><strong>解释器</strong>则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的.</p><h1 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h1><p>在具体计算机上实现一种语言，首先要确定的是表示该语言语义解释的虚拟计算机，一个关键的问题是程序执行时的基本表示是实际计算机上的机器语言还是虚拟机的机器语言。这个问题决定了语言的实现。根据这个问题的回答，可以将程序设计语言划分为两大类：编译型语言和解释型语言。<br><strong>编译型语言</strong>编写的源程序需要经过编译、汇编和链接才能输出目标代码，然后机器执行目标代码，得出运行结果，目标代码由机器指令组成，一般不能独立运行，因为源程序中可能使用了某些汇编程序不能解释引用的库函数，而库函数代码又不在源程序中，此时还需要链接程序完成外部引用和目标模块调用的链接任务，最后输出可执行代码。C、C++、Fortran、Pascal、Ada都是编译实现的。<br> <strong>解释型语言</strong>的实现中，翻译器并不产生目标机器代码，而是产生易于执行的中间代码，这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，软件解释器通常会导致执行效率较低。用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。与编译程序不同的是，解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码后再执行。对于解释型Basic语言，需要一个专门的解释器解释执行 Basic程序，每条语言只有在执行才被翻译。这种解释型语言每执行一次就翻译一次，因而效率低下。</p><h1 id="为什么编译型语言不需要配置环境而解释型语言需要配置环境"><a href="#为什么编译型语言不需要配置环境而解释型语言需要配置环境" class="headerlink" title="为什么编译型语言不需要配置环境而解释型语言需要配置环境"></a>为什么编译型语言不需要配置环境而解释型语言需要配置环境</h1><p>java是一个跨平台性的语言。跨平台就是在一个计算机上编译的字节码文件可以复制到任何一个安装了java环境的计算机上直接使用。我们首先要知道的是所有编程语言编写的应用程序都是先编译为字节码，再由计算机，或者更准确的说，是程序所在的平台，去运行这些字节码才能呈现出最后的结果。而平台是由操作系统(OS)和处理器(CPU)构成的，每个平台都会形成自己独特的机器指令，即该平台可以直接识别，执行的一种由0，1组成的序列代码。因为平台会因为操作系统或者处理器的不同，导致相同的0，1序列表示不同的指令，所以只要OS 或者CPU不同，机器指令就会发生改变。也就是说，在一台机器上编译好的字节码，可能因为机器换了另一种CPU的芯片，使得平台可识别的机器指令发生改变而无法运行，必须重新进行编译。<br>而我们都了解过c/c++，它是不需要安装配置环境的，因为c/c++ 直接对当前所在的平台进行编译，它所编译好的字节码就是当前平台可识别的机器指令。这也是c/c++ 的缺点，编译好的程序并不能跨平台使用。java则不同，只要平台包含java运行环境，编译好的java程序就可以在这个平台上运行。因为java的运行环境中带有java虚拟机，它可以识别java编译好的字节码文件，并把它转换为当前平台可识别的机器码。<br>这里需要注意的一点是，编译语言编译好的字节码文件不能在不同的平台使用，并不代表程序无法运行，只是需要重新编译。</p><h2 id="C语言的编译机制"><a href="#C语言的编译机制" class="headerlink" title="C语言的编译机制"></a>C语言的编译机制</h2><h2 id="python编译机制"><a href="#python编译机制" class="headerlink" title="python编译机制"></a>python编译机制</h2><h2 id="java编译机制"><a href="#java编译机制" class="headerlink" title="java编译机制"></a>java编译机制</h2><p> <a href="https://blog.csdn.net/peng86788/article/details/81296882">https://blog.csdn.net/peng86788/article/details/81296882</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;层次结构&quot;&gt;&lt;a href=&quot;#层次结构&quot; class=&quot;headerlink&quot; title=&quot;层次结构&quot;&gt;&lt;/a&gt;层次结构&lt;/h1&gt;&lt;h2 id=&quot;实际机器（物理设备）&quot;&gt;&lt;a href=&quot;#实际机器（物理设备）&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="编辑语言 组成原理" scheme="http://example.com/tags/%E7%BC%96%E8%BE%91%E8%AF%AD%E8%A8%80-%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Editplus</title>
    <link href="http://example.com/2021/03/10/Editplus/"/>
    <id>http://example.com/2021/03/10/Editplus/</id>
    <published>2021-03-10T09:20:38.000Z</published>
    <updated>2021-03-10T09:20:38.252Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>远行原理</title>
    <link href="http://example.com/2021/02/19/%E8%BF%9C%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2021/02/19/%E8%BF%9C%E8%A1%8C%E5%8E%9F%E7%90%86/</id>
    <published>2021-02-19T06:49:07.000Z</published>
    <updated>2021-03-08T14:12:08.556Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续关于这类写了不下三遍了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;断断续续关于这类写了不下三遍了&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>环境变量</title>
    <link href="http://example.com/2021/02/19/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://example.com/2021/02/19/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2021-02-19T05:21:12.000Z</published>
    <updated>2021-02-19T06:05:44.991Z</updated>
    
    <content type="html"><![CDATA[<p>图形使用是由命令端口演化而来所以Windows保留着dos<br>如果在dos一个命令既不是内部或外部命令的话，也不是可运行的程序等说明没有在相对路径下找到<br>所以我们要配置环境变量就是将它的绝对路径作为变量方便我们在所有的相对路径下使用该程序<br>对了环境变量分为用户（sdminstrator）变量和系统变量这个很容易理解就是一个系统下可以有多个用户，系统变量用户可以共享，用户变量保证了每一个用户的私密性<br>path是路径的意思<br>当在dos执行程序是\如果该程序就在这个路径下的话便执行如果找不到便在path下检索<br>如果在环境变量下配置则可以直接放在path中用分号（：）和之前的路径隔开<br>通常都是双击新建就是把该程序所在的上层目录放到一个我们新建的变量当中动态的在path下做一个引用<br><strong>%%</strong> 是引用的<br><img src="/images/Screenshot 2021-02-19 134214.png"><br><img src="/images/Screenshot 2021-01-24 173701.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;图形使用是由命令端口演化而来所以Windows保留着dos&lt;br&gt;如果在dos一个命令既不是内部或外部命令的话，也不是可运行的程序等说明没有在相对路径下找到&lt;br&gt;所以我们要配置环境变量就是将它的绝对路径作为变量方便我们在所有的相对路径下使用该程序&lt;br&gt;对了环境变量分为用</summary>
      
    
    
    
    
    <category term="电脑使用技巧" scheme="http://example.com/tags/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>随记</title>
    <link href="http://example.com/2021/01/05/%E9%9A%8F%E8%AE%B0/"/>
    <id>http://example.com/2021/01/05/%E9%9A%8F%E8%AE%B0/</id>
    <published>2021-01-05T13:43:04.000Z</published>
    <updated>2021-01-18T21:30:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>属于我的爱情好像来了哈哈哈哈这次绝不错过，算了习惯一个人了</p><p>经历过所以共情形形色色的人生</p><p>一个人走的更快，但想走的远需要一个团队。</p><p>2021年一月十九号<br>凌晨口渴难受索性就起来了昨天晚上回来的都聚了一下像是每年的传统，每年头疼的都是喝酒和抽烟讨厌一身烟味回来洗了澡换了全身的衣服安安稳稳的上床百无聊赖的玩了会手机便睡了。无论那次聚会都有隔阂以前是他们给我的感觉现在是我主动与他们的，每个人都要走自己的路确定自己要走的路一直走下去就好。下次这种无聊的聚会我都不想去了现在嗓子估计要发炎了，眼睛干涩到不行反感在二手烟包裹跟熏香肠一样。价值观人生观依然不同我明确分开是必然，祝福他们好好的我想不打招呼的离开了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;属于我的爱情好像来了哈哈哈哈这次绝不错过，算了习惯一个人了&lt;/p&gt;
&lt;p&gt;经历过所以共情形形色色的人生&lt;/p&gt;
&lt;p&gt;一个人走的更快，但想走的远需要一个团队。&lt;/p&gt;
&lt;p&gt;2021年一月十九号&lt;br&gt;凌晨口渴难受索性就起来了昨天晚上回来的都聚了一下像是每年的传统，每年头疼</summary>
      
    
    
    
    
    <category term="心事" scheme="http://example.com/tags/%E5%BF%83%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>人生志向</title>
    <link href="http://example.com/2020/12/30/%E4%BA%BA%E7%94%9F%E5%BF%97%E5%90%91/"/>
    <id>http://example.com/2020/12/30/%E4%BA%BA%E7%94%9F%E5%BF%97%E5%90%91/</id>
    <published>2020-12-30T00:59:11.000Z</published>
    <updated>2021-01-17T02:59:24.163Z</updated>
    
    <content type="html"><![CDATA[<p>浩渺行无极，杨帆但信风</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浩渺行无极，杨帆但信风&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="人生志向" scheme="http://example.com/tags/%E4%BA%BA%E7%94%9F%E5%BF%97%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://example.com/2020/12/26/Linux/"/>
    <id>http://example.com/2020/12/26/Linux/</id>
    <published>2020-12-26T07:44:12.000Z</published>
    <updated>2020-12-29T02:49:46.067Z</updated>
    
    <content type="html"><![CDATA[<p><strong>基础篇</strong></p><h1 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门</h1><h1 id="vm和Linux的安装"><a href="#vm和Linux的安装" class="headerlink" title="vm和Linux的安装"></a>vm和Linux的安装</h1><h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><p><strong>实操篇</strong></p><h1 id="LIinux"><a href="#LIinux" class="headerlink" title="LIinux"></a>LIinux</h1><h2 id="vi和VIM的使用"><a href="#vi和VIM的使用" class="headerlink" title="vi和VIM的使用"></a>vi和VIM的使用</h2><p>所用的Linux系统都会内建vi文本编辑器<br>vim具有程序编辑的能力，考研看做是vi的增强版，考研主动的以字体颜色辨别语法的正确性，方便程序的设计。代码补完，编译以及错误跳转等方便编译的功能特别丰富，在程序员中被广泛使用。 </p><h3 id="vi和vim的三种模式"><a href="#vi和vim的三种模式" class="headerlink" title="vi和vim的三种模式"></a>vi和vim的三种模式</h3><p><strong>正常模式</strong><br>    以vim打开一个档案就直接进入一般模式（这是默认的模式）。在这个模式中，你可以使用[上下左右]按键移动光标，你可以使用[删除字符]或[删除整行]来处理档案内容，以可以[粘贴复制]来处理你的文件数据。快捷键<br><strong>插入模式</strong><br>    按下i,l,o,O,a等任何一个字母进入编辑模式。<br><strong>命令模式</strong><br>    在这个模式当中，可以提供你相关指令，完成读取，存盘，替换，离开vim，显示行号等的动作则是在此模式中达成的。</p><h3 id="vi和vim模式的相互切换"><a href="#vi和vim模式的相互切换" class="headerlink" title="vi和vim模式的相互切换"></a>vi和vim模式的相互切换</h3><img src="/images/Screenshot 2020-12-29 091432.png"><h3 id="vi和vim快捷键"><a href="#vi和vim快捷键" class="headerlink" title="vi和vim快捷键"></a>vi和vim快捷键</h3><p>1.复制当前行yy，复制当前行向下5行5yy。粘贴p。<br>2.删除当前行dd，删除当前行向下5行5dd。<br>3.在文件中查找某个单词[命令行下/关键词，回车查找，输入n就是查找下一个]<br>4.设置文件的行号，取消文件的行号。[命令行下：set nu和：set nonu]<br>5.编辑/etc/profile文件，使用快捷键到底文档的最末端[G]和最首行[gg]<br>6.在一个文件中输入”hello”,然后又撤销这个动作U<br>7.编辑/etc/profile文件，并将光标移动到20行shift+g.</p><h1 id="Linux之大数据定制篇"><a href="#Linux之大数据定制篇" class="headerlink" title="Linux之大数据定制篇"></a>Linux之大数据定制篇</h1><p><strong>shell</strong><br>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序。<br><img src="/images/图片1.png"></p><h2 id="shell脚本的执行方式"><a href="#shell脚本的执行方式" class="headerlink" title="shell脚本的执行方式"></a>shell脚本的执行方式</h2><p>1.脚本以#！/bin/bash开头<br>2.脚本需要有可执行权限</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;基础篇&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;Linux入门&quot;&gt;&lt;a href=&quot;#Linux入门&quot; class=&quot;headerlink&quot; title=&quot;Linux入门&quot;&gt;&lt;/a&gt;Linux入门&lt;/h1&gt;&lt;h1 id=&quot;vm和Linux的安装&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/2020/12/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2020/12/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-12-26T07:43:32.000Z</published>
    <updated>2021-03-11T09:44:09.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统的演化"><a href="#操作系统的演化" class="headerlink" title="操作系统的演化"></a>操作系统的演化</h1><h3 id="无操作系统"><a href="#无操作系统" class="headerlink" title="无操作系统"></a>无操作系统</h3><p>人工操作<br>用户独占<br>CPU等待人工操作<br>资源利用率很低</p><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>无需等待人工操作<br>批量输入任务<br>资源利用率提升<br><strong>多道程序设计</strong><br>    是指在计算机内存中同时存放多个程序<br>    多道程序在计算机的管理程序之下相互穿插远行<br>    <strong>对多道程序的管理是操作系统的重要功能</strong></p><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>人——机交互<br>多用户共享<br>及时调试程序<br>资源利用率提升</p><h1 id="Linux的存储管理"><a href="#Linux的存储管理" class="headerlink" title="Linux的存储管理"></a>Linux的存储管理</h1><h2 id="Buddy内存管理算法"><a href="#Buddy内存管理算法" class="headerlink" title="Buddy内存管理算法"></a>Buddy内存管理算法</h2><pre><code>Buddy算法是经典的</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统的演化&quot;&gt;&lt;a href=&quot;#操作系统的演化&quot; class=&quot;headerlink&quot; title=&quot;操作系统的演化&quot;&gt;&lt;/a&gt;操作系统的演化&lt;/h1&gt;&lt;h3 id=&quot;无操作系统&quot;&gt;&lt;a href=&quot;#无操作系统&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="408" scheme="http://example.com/tags/408/"/>
    
  </entry>
  
  <entry>
    <title>心情不好</title>
    <link href="http://example.com/2020/12/25/%E5%BF%83%E6%83%85%E4%B8%8D%E5%A5%BD/"/>
    <id>http://example.com/2020/12/25/%E5%BF%83%E6%83%85%E4%B8%8D%E5%A5%BD/</id>
    <published>2020-12-25T08:11:42.000Z</published>
    <updated>2020-12-25T08:38:25.752Z</updated>
    
    <content type="html"><![CDATA[<p>能力不够，对自己还是挺失望的<br>每一个不起舞的日子的，都是对生命的辜负，请你逼自己一把，就一步一步的的来。<br>我其实也需要别人来来拯救，我希望你能看出我的自卑和敏感<br>谁都别说让我一个人躲一躲，我有时候就想一个人呆在角落看着他们做自己的事，不要跟我讲话让我一个自闭就好了，我不想陪着你笑我不想和你就换感情，我不想跟别人有任何瓜葛。与其被别人喜欢不如被别人讨厌，如果你讨厌我，我其实还是蛮开心的。不会让别人对自己失望，只是单纯的自己对自己失望。<br>我很不好请你早点出现，我需要你真的很需要</p><img src="/images/mmexport1606648388931.png">搞怪的不是红绿灯，也不是时间问题，而是我数不清的犹豫，人生的出场顺序真的重要，也许我们迟一点相遇我可能不会那么自卑，或许我会勇敢一些。]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;能力不够，对自己还是挺失望的&lt;br&gt;每一个不起舞的日子的，都是对生命的辜负，请你逼自己一把，就一步一步的的来。&lt;br&gt;我其实也需要别人来来拯救，我希望你能看出我的自卑和敏感&lt;br&gt;谁都别说让我一个人躲一躲，我有时候就想一个人呆在角落看着他们做自己的事，不要跟我讲话让我一个自</summary>
      
    
    
    
    
    <category term="情绪" scheme="http://example.com/tags/%E6%83%85%E7%BB%AA/"/>
    
  </entry>
  
  <entry>
    <title>装机试玩</title>
    <link href="http://example.com/2020/12/19/%E8%A3%85%E6%9C%BA%E8%AF%95%E7%8E%A9/"/>
    <id>http://example.com/2020/12/19/%E8%A3%85%E6%9C%BA%E8%AF%95%E7%8E%A9/</id>
    <published>2020-12-19T07:45:34.000Z</published>
    <updated>2020-12-21T08:30:43.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="AMD-CPU的安装"><a href="#AMD-CPU的安装" class="headerlink" title="AMD CPU的安装"></a>AMD CPU的安装</h2><p>在cpu的底座下有一个金属把手往下推这个金属把手然后将其抬起至九十度与主板垂直<br><img src="/images/IMG_20201221_131921.jpg"></p><p>然后拿起CPU正反都可以看见一个金属三角，在底座上也有一个小三角。我们将CPU的小三角和CPU插槽底座对齐，然后将CPU平稳的放下上下晃动确保安装到位。<br><img src="/images/IMG_20201221_131941.jpg"></p><p>扣回刚才打开的金属把手。<br><img src="/images/IMG_20201221_132002.jpg"></p><p>至此AM4接口的Ryzen系列CPU就算是安装完成<br>注释：AMD桌面处理器拥有AM3+、FM2+、AM1三种不同接口，分别用于高端CPU、主流APU、低端APU，而从2016年开始，它们将全部统一为新的AM4。CPU插槽.</p><h2 id="intel-CPU的安装"><a href="#intel-CPU的安装" class="headerlink" title="intel CPU的安装"></a>intel CPU的安装</h2><p>在CPU插槽底座的右边可以看见像弯钩一样的金属把手用力下压这个把手然后向右边拽向上抬起就可以打开CPU插槽的保护盖</p><p>拿起CPU可以在左上角和右上角看见类似小耳朵一样的豁口底座插槽有对应的俩个突起，与其对其用手捏住CPU的上下平稳的将CPU放在底座针脚上上下晃动CPU确保安装到位</p><p>然后将顶盖放下将底部的豁口插入下方的螺丝柱下面最后用比较大的力气将弯钩状把手扣回原来的地方顶部的黑色塑料保护壳会自动脱落</p><p><strong>注意在安装过程中不要触碰到CPU底座中间的针脚他们异常脆弱如果不小心碰外了用镊子放大镜修复或者联系卖家返厂更换底座插槽一般五十到一百</strong></p><h1 id="内存条"><a href="#内存条" class="headerlink" title="内存条"></a>内存条</h1><p>主板最右侧竖着的四个插槽就是内存插槽，内存条在主板上有一定的优先级从左往右数是二四插槽为优先插槽一三槽为次要插槽（不建议插三根内存会导致系统的略微的不稳定）在安装内存之前需要先打开内存插槽上的卡扣<br><img src="/images/IMG_20201221_133824.jpg"><br>拿起内存条可以看见内存金手指中间的部分有一个小的豁口将其与主板内存插槽中间的塑料突起对齐，用力按压内存的俩头直至听见咔嚓两声内存上方的卡扣会自动扣合（如果没有安装到底会出现开不机的情况）<br><img src="/images/IMG_20201221_133635.jpg"><br><img src="/images/IMG_20201221_133718.jpg"></p><h1 id="固态硬盘SSD"><a href="#固态硬盘SSD" class="headerlink" title="固态硬盘SSD"></a>固态硬盘SSD</h1><h2 id="M-2接口"><a href="#M-2接口" class="headerlink" title="M.2接口"></a>M.2接口</h2><p>  这个主板没有M.2接口</p><h2 id="stat接口"><a href="#stat接口" class="headerlink" title="stat接口"></a>stat接口</h2><h1 id="散热器的安装（风冷和水冷）"><a href="#散热器的安装（风冷和水冷）" class="headerlink" title="散热器的安装（风冷和水冷）"></a>散热器的安装（风冷和水冷）</h1><p>AMD主板上通常会在CPU位置自带上下两个塑料卡扣用于安装原装散热也有部分第三方散热也会直接用这个扣具进行安装有的自带扣具所以不需要原装扣具因此首先将原装扣具进行拆除拧下四个角螺丝即可拆下塑料卡扣之后将主板翻过来取走主板背面的原装背板（T400炫彩扣具的安装我们将螺丝插入对应的AM4对应的孔位当中并将塑料卡扣固定好以此类推安装余下至此背板安装完成之后将背板安装到主板上从主板背面对其四个螺丝的孔位将螺丝穿过去把背板贴在主板的后面之后拧上固定背板用的四个六边形螺丝）散热塔的安装（在散热塔的底座上有两个固定扣具的螺丝口使用AM4接口的长条将扣具固定到散热塔底座上，接触部分将保护膜撕掉）<strong>接下来将CPU表面涂抹导热硅胶作用是填充散热器与CPU表面的微小空隙方便热量从CPU传递给散热器涂一点就可以了画X就行。</strong>将散热塔的四个弹簧螺丝对准之前固定在CPU插槽底座四角的四个六边形螺丝然后对角线顺序拧紧螺丝</p><p><strong>扣具</strong><br><img src="/images/IMG_20201221_135851.jpg"><br><img src="/images/1608530419987.jpg"></p><p><strong>散热塔本体</strong><br><img src="/images/1608530766809.jpg"></p><p><strong>接下来我们将风扇从侧方扣制散热塔本体上之后将风扇供电线接到主板的CPUfan1上（部分主板为了防止CPU出现高温导致烧毁开机BIOS自检提示CPUfanError）目前主板上有很多风扇接口为了避免错误还是要看说明书确保第一个风扇接在FAN1上）</strong></p><img src="/images/QQ图片20201221162956.jpg"><img src="/images/20201221162904.jpg"><img src="/images/QQ图片20201221163021.jpg"><img src="/images/QQ图片20201221163034.jpg"><p><strong>12号下午浪费了四个小时时间装到机箱中，我真的想吐在这里。之前拆的之后装了一次还可以正常运行现在装进机箱中反而不行了心累不知道什么原因这篇blog暂时不写了等考完试留校在说吧</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h1&gt;&lt;h2 id=&quot;AMD-CPU的安装&quot;&gt;&lt;a href=&quot;#AMD-CPU的安装&quot; class=&quot;headerlink&quot; title=&quot;A</summary>
      
    
    
    
    
    <category term="装机" scheme="http://example.com/tags/%E8%A3%85%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>javaSE</title>
    <link href="http://example.com/2020/12/14/java/"/>
    <id>http://example.com/2020/12/14/java/</id>
    <published>2020-12-14T04:26:16.000Z</published>
    <updated>2021-01-04T00:23:34.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我之前有认真学过C语言但基本都是学的一直半解疫情期间在家认真做个笔记，虽然笔记已经找不到了并且内容也已经忘了差不多了。我现在学java的状态和之前学c状态是一样的，所以开这篇Java的技术blog提醒自己认真学习同时警示自己的学习状态。以前一直沉迷与硬件的知识想知道二进制字节码被操作系统翻译成操作码的是怎么样把硬件的API封装成函数调用从而进行操作的所以自己做了一个八位的cpu，但完全高估了自己的能力导致自己郁闷怀疑人生。所以有些事还是浅尝辄止，专心做当下的事。<br><strong>工具</strong><br>    Editplus<br>    eclipse<br>    IntelljIDEA<br><strong>Java基础</strong><br>java基础是学生JavaEE，大数据，Android开发是基石。</p><img src="/images/Screenshot 2020-12-30 192829.png "><h1 id="一-Java学习前言"><a href="#一-Java学习前言" class="headerlink" title="一 Java学习前言"></a>一 Java学习前言</h1><h2 id="认识java"><a href="#认识java" class="headerlink" title="认识java"></a>认识java</h2><h3 id="java面向对象语言"><a href="#java面向对象语言" class="headerlink" title="java面向对象语言"></a>java面向对象语言</h3><p><strong>java是一种面向对象语言，真正的面向对象，任何函数和变量都以类(class)封装起来。</strong></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.<strong>既然是真正的面向对象，那就要做到彻底的封装。这是java和C以及c++最大的不同，java所有的源码以及编译后的文件都以类的形式存在。</strong> java没有所谓的类外部定义，所有的函数（方法）以及变量（属性）都必须在类内部定义。这样就不会出现一个类被切割成这里一块那里一块的情况，这样做使得整个程序的结构异常清晰。<br>2.<strong>是完全屏蔽了指针，同时引入了垃圾回收机制（GC）</strong> 写出来的任何一个程序内存上的开销，都不受你控制。乍一看，似乎你受到了束缚，但实际上不是这样，因为虽然你的程序无法对内存进行管理，降低了一定的速度，但你的程序会非常非常的安全，因为你无法调用一个空指针.<br>3.<strong>安全虚拟机跨平台</strong> java程序特点是安全。这个安全是针对你的系统来说得，系统在跑了java程序之后会特别地稳定，而且还能跨平台。如果使用用c/c++，要针对每一款手机写一套程序。</p><h2 id="认识JDK"><a href="#认识JDK" class="headerlink" title="认识JDK"></a>认识JDK</h2><p>99年sun公司将java应用平台做一个划分这三大块<strong>这三大块就是JSE,JEE以及JM。</strong> <strong>java 2的标准版(java 2 standard edition)，也就是最基础的java语言部分，无论学什么java技术，J2SE都是必须掌握的，要使用J2SE就必须安装JDK（java development kit）。</strong></p><p><strong>JDK包含有五个部分：核心API，集成API，用户界面API，发布技术还有java虚拟机（JVM）。先说运行环境，运行环境最主要要说的就是java虚拟机（JVM）</strong><br><img src="/images/df20201214175019.jpg "></p><h3 id="JDK的JVM"><a href="#JDK的JVM" class="headerlink" title="JDK的JVM"></a>JDK的JVM</h3><p>JVM（Java java的设计者们提出了一个虚拟机的概念，在操作系统之上建立一个统一的平台，实现跨平台的功能。程序员所写的每一个程序都先运行在虚拟机上，所有操作都必须经过虚拟机才能和操作系统交互，这样做不仅统一了所有操作系统，同时也保证了操作系统的安全。要死机的话，死的是虚拟机（JVM）而操作系统并不会受此影响，而我们所说的java运行环境指的主要是JVM。<br>|          |      program    |           |<br>|:——-:|:————- | ———-:|<br>|     |   JVM      |     |<br>|unix|Linux|window|</p><h3 id="JDK的API"><a href="#JDK的API" class="headerlink" title="JDK的API"></a>JDK的API</h3><p>API（Application Programming Interface）应用程序编程接口。在java里面，就是一些已经写好了的类打成的包。常用的类，可以简单理解成java的工具集。</p><h3 id="JDK的发布技术"><a href="#JDK的发布技术" class="headerlink" title="JDK的发布技术"></a>JDK的发布技术</h3><p>JDK的发布技术就是编译器，将.java文件转换成.class文件的一种技术。这三部分组成了JDK，有了JDK，就可以开发出J2SE应用软件了，最原始的只要用一个记事本写几行代码就可以了，但一般来说我们会使用效果比较好的开发工具，也就是IDEA。</p><p><strong>总之，我们通过IDEA写的源代码以.class文件文本储存，通过JDK编译成.class的字节码文本文件然后这个class文件就能够被jvm加载，而不同的操作系统通过运行对应版本jvm来载入这个class文件运行，则实现了平台无关性。</strong></p> <img src="/images/ddd.png"><h1 id="二-简单认识java应用程序"><a href="#二-简单认识java应用程序" class="headerlink" title="二 简单认识java应用程序"></a>二 简单认识java应用程序</h1><h3 id="一-编写和保存源代码"><a href="#一-编写和保存源代码" class="headerlink" title="一 编写和保存源代码"></a>一 编写和保存源代码</h3><h5 id="编写源代码"><a href="#编写源代码" class="headerlink" title="编写源代码"></a>编写源代码</h5><p> 使用任何一个文本编辑器都可以，vscode  notepad++ …</p><h5 id="保存源代码"><a href="#保存源代码" class="headerlink" title="保存源代码"></a>保存源代码</h5><p> 如果源文件中有很多类，<strong>那么只能有一个是public类</strong>，如果有一个类是public类，<strong>那么源文件的名字必须与这个类的名字完全相同</strong> ，扩展名是java；如果源文件没有public类，那么源文件的名字只要和某个类的名字相同，<strong>并且扩展名是Java</strong>就可以了。</p><h3 id="二-编译"><a href="#二-编译" class="headerlink" title="二 编译"></a>二 编译</h3><p> 进入某一个磁盘中的相关目录下使用javac编译器文件编译源文件</p><h3 id="三-运行"><a href="#三-运行" class="headerlink" title="三 运行"></a>三 运行</h3><h5 id="应用程序的主类"><a href="#应用程序的主类" class="headerlink" title="应用程序的主类"></a>应用程序的主类</h5><p> 一个Java应用程序必须有一个类含有<br> public static void main (String args[])</p><h5 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h5><p> 使用Java虚拟机中的Java解释器（java.exe)来解释执行其字节码文件。Java应用程序中是从主类的main方法开始执行。因此，需要进入主类字节码所在的目录，然后使用Java解释器（java.exe)运行主类的字节码。</p><p> <strong>总结</strong><br> JDK中<br>javac：Java编译器，将Java源代码换成字节代；<br>java：Java解释器，直接从类文件执行Java应用程序代码；<br>先编译  <em>.java文件――――&gt;</em>.class文件<br>运行   *.class ――加载――&gt; JVM<br>jvm加载二进制文件</p><p>javac编译后得到的class文件是二进制指令，但不是机器指令，而是java虚拟机可识别的指令。这样class文件就有了可移植行。你可以把class文件拿到windows、linux或者solaris等不同的系统上去，在jvm上执行。<br>java是启动jvm，jvm负责对class文件的内容进行处理，将字节码文件解释或者编译为机器指令，执行。</p><h1 id="三-Java基础"><a href="#三-Java基础" class="headerlink" title="三 Java基础"></a>三 Java基础</h1><h3 id="0-1-注释"><a href="#0-1-注释" class="headerlink" title="0.1 注释"></a>0.1 注释</h3><p> 单行注释   //<br>多行注释  /**     */<br>文本注释  //javadoc 文档注释<br>文档注释内容可以被JDK提供的工具Javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p><p>System.out.println(): 先输出数据，然后换行<br>System.out.print(): 只输出数据</p><h3 id="0-2-标识符和关键字"><a href="#0-2-标识符和关键字" class="headerlink" title="0.2 标识符和关键字"></a>0.2 标识符和关键字</h3><p><strong>标识符</strong><br>Java所有的组成部分都需要名字。类名，变量名以及方法名都被称为<strong>标识符</strong>。所有的标识符都应该以大小写字母或者$,_数字都可以，但首字母不能是数字且不能是<strong>关键字</strong><br>被Java语言赋予了特殊含义，用做专门用途的字符串。关键字中所有的字母都为小写。<br><strong>保留字</strong><br>goto const<br><strong>命令的规范</strong><br>包名：所有字母都小写<br>类名 接口名：所有单词首字母大写<br>变量名 方法名：第一个单词首字母小写，其余单词首字母大写<br>常量名：所有字母都大写</p><h3 id="0-3数据类型"><a href="#0-3数据类型" class="headerlink" title="0.3数据类型"></a>0.3数据类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><img src="/images/v2-a4de2da2942089375382858919e3ae63_hd.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;整数</span><br><span class="line">int num1&#x3D;10;</span><br><span class="line">byte num2&#x3D;20;</span><br><span class="line">short num3 &#x3D;30;</span><br><span class="line">long num4&#x3D;30L; Long类型要在数字后面加个L</span><br><span class="line">&#x2F;&#x2F;浮点数</span><br><span class="line">float num5&#x3D;5.1F;&#x2F;&#x2F;float类型要在数字后面加个F</span><br><span class="line">double num6&#x3D;3.1415926535;</span><br><span class="line">&#x2F;&#x2F;字符</span><br><span class="line">char name &#x3D;&#39;国&#39;;&#x2F;&#x2F; 可以是汉字，因为是Unicode编码也可以是进制数</span><br><span class="line">&#x2F;&#x2F;布尔值</span><br><span class="line">boolean flag&#x3D;true;</span><br></pre></td></tr></table></figure><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><h5 id="接口API"><a href="#接口API" class="headerlink" title="接口API"></a>接口API</h5><h3 id="0-4类型转换"><a href="#0-4类型转换" class="headerlink" title="0.4类型转换"></a>0.4类型转换</h3><p>double &gt; float &gt; long &gt; int &gt; short &gt; byte</p><h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p><strong>· 所有byte/short/char都被提升为int。<br>· 如果有一个操作数为long，整个表达式提升为long。float和double情况也一样</strong>。</p><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>强制转换时会出现内存溢出<br>强制转换格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(target-type) value;</span><br><span class="line">int money&#x3D;100000000；</span><br><span class="line">int year&#x3D;100；</span><br><span class="line">int total&#x3D;money*years;&#x2F;&#x2F;计算时内存溢出了</span><br><span class="line">long total2&#x3D;money*years;&#x2F;&#x2F;默认时int，转换之前存在问题</span><br><span class="line">long total2&#x3D;money*(long)years;&#x2F;&#x2F;先把一个数转换为Long</span><br></pre></td></tr></table></figure><p><strong>拓展知识点</strong>：Java是面向对象语言，其概念为一切皆为对象，但基本数据类型算是个例外哦，基本数据类型大多是面向机器底层的类型，它是 “值” 而不是一个对象，它存放于“栈”中而不是存放于“堆”中，但Java一切皆为对象的概念不是说说而已，它为每一个基本数据类型都做了相应的包装类，我们日常使用中大多情况下都会使用着这些包装类：<br>boolean Boolean<br>char Character<br>byte Byte<br>short Short<br>int Integer<br>long Long<br>float Float<br>double Double<br>String（字符串）<br>包装类就是一个对象，它存放于“堆”中。</p><h3 id="0-5-变量"><a href="#0-5-变量" class="headerlink" title="0.5 变量"></a>0.5 变量</h3><p>java变量时程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</p><h5 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;属性：变量</span><br><span class="line">   &#x2F;&#x2F;类变量 static</span><br><span class="line">   &#x2F;&#x2F;实列变量:从属于对象；如果不自行初始化，那么这个类型为默认值（布尔默认为F）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;main方法</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">&#x2F;&#x2F;局部变量，必须声明和初始化值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类变量 static</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;其他方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0-6-常量"><a href="#0-6-常量" class="headerlink" title="0.6 常量"></a>0.6 常量</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final 常量名&#x3D;值；</span><br></pre></td></tr></table></figure></code></pre><p><strong>变量的命名规范</strong><br>所有变量，方法，类名：见面知意<br>类成员变量：首字母小写和驼峰原则：monthSalary<br>局部变量:首字母小写和驼峰原则<br>常量：大写字母和下划线：MAX_VAJUE<br>类名：首字母小写和驼峰原则：Man,GoodMan<br>方法名：首字母小写和驼峰原则：run（），runRun();</p><h3 id="0-7-运算符与表达式"><a href="#0-7-运算符与表达式" class="headerlink" title="0.7 运算符与表达式"></a>0.7 运算符与表达式</h3><h4 id="算术运算符与算术表达式：-，-，-，-，-，-，–"><a href="#算术运算符与算术表达式：-，-，-，-，-，-，–" class="headerlink" title="算术运算符与算术表达式：+，-，*，/，%，++，–"></a>算术运算符与算术表达式：+，-，*，/，%，++，–</h4><h4 id="赋值运算符与赋值表达式-，-，-，-，"><a href="#赋值运算符与赋值表达式-，-，-，-，" class="headerlink" title="赋值运算符与赋值表达式 = ，+=，-=，*=，/="></a>赋值运算符与赋值表达式 = ，+=，-=，*=，/=</h4><h4 id="关系运算符与关系表达式-gt-lt-gt-lt-instanceof"><a href="#关系运算符与关系表达式-gt-lt-gt-lt-instanceof" class="headerlink" title="关系运算符与关系表达式 &gt;,&lt;,&gt;=,&lt;=,==,!+instanceof"></a>关系运算符与关系表达式 &gt;,&lt;,&gt;=,&lt;=,==,!+instanceof</h4><h4 id="逻辑运算符与逻辑表达式-amp-amp"><a href="#逻辑运算符与逻辑表达式-amp-amp" class="headerlink" title="逻辑运算符与逻辑表达式 &amp;&amp;,||,!"></a>逻辑运算符与逻辑表达式 &amp;&amp;,||,!</h4><h4 id="位运算符-amp-lt-lt-gt-gt-gt-gt-gt"><a href="#位运算符-amp-lt-lt-gt-gt-gt-gt-gt" class="headerlink" title="位运算符&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;"></a>位运算符&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左移*2    &lt;&lt;</span><br><span class="line">右移&#x2F;2    &gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="条件运算符？-："><a href="#条件运算符？-：" class="headerlink" title="条件运算符？ ："></a>条件运算符？ ：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x?y:z</span><br><span class="line">&#x2F;&#x2F;如果x&#x3D;&#x3D;true,则结果为y,否则为z;</span><br></pre></td></tr></table></figure><p><strong>字符串连接符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;&quot;+a+b); 1020</span><br><span class="line">System.out.println(a+b+&quot;&quot;); 30</span><br><span class="line">&#x2F;&#x2F;连接符如果左右有字符的话那么另一个也会被转化为字符</span><br></pre></td></tr></table></figure><p><strong>math类</strong><br><strong>运算符优先级</strong></p><h3 id="0-8-包机制"><a href="#0-8-包机制" class="headerlink" title="0.8 包机制"></a>0.8 包机制</h3><p>公司域名倒置作为包名<br>为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包。使用”import”语句可完成此功能。</p><p><strong>阿里巴巴开发手册</strong></p><h3 id="0-9-javaDoc"><a href="#0-9-javaDoc" class="headerlink" title="0.9 javaDoc"></a>0.9 javaDoc</h3><p>javadoc命令用来生成自己的API文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*@author xiyan</span><br><span class="line">*@version 1.0</span><br><span class="line">*@return</span><br><span class="line">*@thorws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">public String test(String name) throws Exception&#123;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java帮助文档</strong><br><a href="https://www.oracle.com/cn/java/technologies/java-se-api-doc.html">https://www.oracle.com/cn/java/technologies/java-se-api-doc.html</a></p><h1 id="四-流程控制"><a href="#四-流程控制" class="headerlink" title="四 流程控制"></a>四 流程控制</h1><h2 id="一-用户交互Scanner"><a href="#一-用户交互Scanner" class="headerlink" title="一 用户交互Scanner"></a>一 用户交互Scanner</h2><p>java给我们提供了这样一个工具类，我们可以获取用户的输入。java.util.Scanner是java5的新特性，我们可以通过Scanner类来获取用户的输入。<br><strong>基本语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**Scanner scanner &#x3D; new Scanner(System.in);**&#x2F;&#x2F;一个扫描器对象，用于接收键盘数据</span><br><span class="line">**scanner.close();**&#x2F;&#x2F;凡是属于IO流的类如果 不关闭会一直占用资源</span><br><span class="line">if(scanner.hasNext())</span><br><span class="line">if(scanner.hasNextLine)&#x2F;&#x2F;通过Sanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext()与hasNextLine()判断是否还有输入的数据</span><br><span class="line"></span><br><span class="line">String s &#x3D;scanner.next;</span><br><span class="line">String s &#x3D;scanner.nextLine;</span><br></pre></td></tr></table></figure><p><strong>next()</strong><br>1.一定要读到有效字符才可以结束输入<br>2.对输入有效字符之前遇到的空白，next()方法会自动将其去掉。<br>3.只有输入有效的字符后才将其后面输入的空白作为分隔符或者结束符<br>4.<strong>next()不能得到带有空白的字符串</strong></p><p><strong>nextLine()</strong><br>1.以enter为结束符，也就是说nextLine（）方法返回的是输入回车之前的所有字符。<br>2.可以获得空白</p><h2 id="二-顺序结构"><a href="#二-顺序结构" class="headerlink" title="二 顺序结构"></a>二 顺序结构</h2><p>语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，<strong>它是任何一个算法都离不开的基本算法结构</strong></p><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="if选择结构"><a href="#if选择结构" class="headerlink" title="if选择结构"></a>if选择结构</h3><h4 id="if单选择结构"><a href="#if单选择结构" class="headerlink" title="if单选择结构"></a>if单选择结构</h4><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果布尔表达式为true将执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/Screenshot 2020-12-16 131958.png"><h4 id="if双选择结构"><a href="#if双选择结构" class="headerlink" title="if双选择结构"></a>if双选择结构</h4><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果布尔表达式为true将执行的语句</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    &#x2F;&#x2F;如果布尔表达式为false将执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/Screenshot 2020-12-16 133300.png"><h4 id="嵌套if选择结构"><a href="#嵌套if选择结构" class="headerlink" title="嵌套if选择结构"></a>嵌套if选择结构</h4><h4 id="if多选择结构"><a href="#if多选择结构" class="headerlink" title="if多选择结构"></a>if多选择结构</h4><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式1)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果布尔表达式1为true将执行的语句</span><br><span class="line">&#125;else if(布尔表达式2)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果布尔表达式2为true将执行的语句</span><br><span class="line">&#125;else if(布尔表达式3)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果布尔表达式3为true将执行的语句</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    &#x2F;&#x2F;如果以上布尔表达式都不为ture执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/Screenshot 2020-12-16 133630.png"><h3 id="Switch多选择结构"><a href="#Switch多选择结构" class="headerlink" title="Switch多选择结构"></a>Switch多选择结构</h3><p>switch case语句判断一个变量与一系列值中某个值是否相等，每一个值称为一个分支。<br><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch(expression)&#123;</span><br><span class="line">    case value : &#x2F;&#x2F;语句</span><br><span class="line">        break;&#x2F;&#x2F;可选</span><br><span class="line">    case value : &#x2F;&#x2F;语句</span><br><span class="line">        break;&#x2F;&#x2F;可选</span><br><span class="line">    &#x2F;&#x2F;可以有任意数量的case语句</span><br><span class="line"></span><br><span class="line">    default : 语句 &#x2F;&#x2F;可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while（布尔表达式）&#123;</span><br><span class="line">    &#x2F;&#x2F;循环内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.只要布尔表达式为true，循环就会一直执行下去我们大多数是会让循环停止下来的，我们需要一个让表达式失效的方法来结束循环<br>2.少部分情况需要循环一直执行比如服务器的请求相应监听等。</p><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do  while循环"></a>do  while循环</h3><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    &#x2F;&#x2F;代码语句</span><br><span class="line">&#125;while（布尔表达式）;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件也至少执行一次。<br>2.do …while循环和while循环相似，不同的是，do…<br>while循环至少会执行一次.</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(初始化,布尔表达式 ,迭代)&#123;</span><br><span class="line">    &#x2F;&#x2F;代码语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最先执行初始化步骤，可以声明一种类型，但可初始化一个或者多个循环控制变量，也可以是空语句。然后，检测布尔表的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环后面的语句。执行一次循环后，更新循环控制变量（迭代因子控制循环变量的增减）。<br>再次检测布尔表达式。循环执行上面的过程。</p><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><h1 id="五-方法"><a href="#五-方法" class="headerlink" title="五 方法"></a>五 方法</h1><h2 id="方法的定义和调用"><a href="#方法的定义和调用" class="headerlink" title="方法的定义和调用"></a>方法的定义和调用</h2><p><strong>java方法是语句的集合，它们在一起执行一个功能</strong><br>1.方法是解决一类问题的步骤的有序组合<br>2.方法包含于类或对象中<br>3.方法在程序中被创建，在其他地方被引用<br><strong>设计方法的原则</strong>方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成一个功能，这样利于我们后期的扩展。 </p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>方法中包含一个方法头和一个方法体</strong><br><strong>修饰符：</strong>这是可选的告诉编译器如何调用该方法。定义该方法的访问类型。<br><strong>返回值类型：</strong>方法可能会放回值，returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字void。<br><strong>方法名</strong>是方法实际名称。方法名和参数表共同构成方法签名。<br><strong>参数类型</strong>参数就像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或者变量。参数列表时指方法的参数类型，顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</p><h5 id="形式参数：在方法被调用时用于接收外界输入的数据。站位符"><a href="#形式参数：在方法被调用时用于接收外界输入的数据。站位符" class="headerlink" title="形式参数：在方法被调用时用于接收外界输入的数据。站位符"></a>形式参数：在方法被调用时用于接收外界输入的数据。站位符</h5><h5 id="实参调用方法时实际传给方法的数据"><a href="#实参调用方法时实际传给方法的数据" class="headerlink" title="实参调用方法时实际传给方法的数据"></a>实参调用方法时实际传给方法的数据</h5><p><strong>方法体</strong>方法体包含具体的语句，定义该方法的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 参数名）&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    return 返回值；</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;return除了可以返回值也可以终止函数</span><br></pre></td></tr></table></figure><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p><strong>调用方法：对象名.方法名（实参列表）</strong><br>当方法返回一个值的时候，方法调用通常被当做一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int larger &#x3D; max(30,40);</span><br></pre></td></tr></table></figure><p>如果方法返回值是void，方法调用一定是一条语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Hello,Kuangshen&quot;);</span><br></pre></td></tr></table></figure><p><strong>值传递（Java）和引用传递</strong></p><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>重载就是在一个类中，有相同的函数名称，但形参不同的函数。<br><strong>方法的重载规则</strong><br>1.方法名称必须相同<br>2.参数列表必须不同（个数不同，或类型不同，参数排序顺序不同）<br>3.方法的返回值类型可以相同也可以不相同。<br>4.仅仅返回值类型不同不足以成为方法的重载。<br><strong>实现理论</strong><br>方法的名称相同时，编译器会根据调用方法的参数个数，参数类型等逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。<br><img src="/images/Screenshot 2020-12-17 134237.png"></p><h2 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h2><p>有时候希望运行一个程序时候再传递给他消息。这要靠传递命令行参数给main（）函数实现。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>1.JDK1.5开始，Java支持传递同类型的可变参数给一个方法<br>2.在方法声明中，在指定参数类型后加一个省略号（…）<br>3.一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。<br><img src="/images/"><br><img src="/images/Screenshot 2020-12-16 202428.png"></p><h2 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h2><p><strong>递归结构</strong><br> 递归头：什么时候不调用自身方法。如果没有头将陷入死循环。<br> 递归体：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我之前有认真学过C语言但基本都是学的一直半解疫情期间在家认真做个笔记，虽然笔记已经找不到了并且内容也已经忘了差不多了。我现在学java的状态</summary>
      
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Idea使用技巧</title>
    <link href="http://example.com/2020/12/10/Idea%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2020/12/10/Idea%E4%BD%BF%E7%94%A8/</id>
    <published>2020-12-10T07:39:35.000Z</published>
    <updated>2021-03-11T09:44:07.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、IntelliJ-IDEA-介绍"><a href="#一、IntelliJ-IDEA-介绍" class="headerlink" title="一、IntelliJ IDEA 介绍"></a>一、IntelliJ IDEA 介绍</h1><h3 id="1-JetBrains-公司介绍"><a href="#1-JetBrains-公司介绍" class="headerlink" title="1.JetBrains 公司介绍"></a>1.JetBrains 公司介绍</h3><p>IDEA(<a href="https://www.jetbrains.com/idea/)%E6%98%AF">https://www.jetbrains.com/idea/)是</a> JetBrains 公司的产品，公司旗下还有其它产品，比如：<br> WebStorm：用于开发 JavaScript、HTML5、CSS3 等前端技术；<br> PyCharm：用于开发 python<br> PhpStorm：用于开发 PHP<br> RubyMine：用于开发 Ruby/Rails<br> AppCode：用于开发 Objective - C/Swift<br> CLion：用于开发 C/C++<br> DataGrip：用于开发数据库和 SQL<br> Rider：用于开发.NET<br> GoLand：用于开发 Go<br> Android Studio：用于开发 android(google 基于 IDEA 社区版进行迭代)<br> <img src="/images/Screenshot 2020-12-10 165040.png"></p><h3 id="2-IntelliJ-IDEA-介绍"><a href="#2-IntelliJ-IDEA-介绍" class="headerlink" title="2. IntelliJ IDEA 介绍"></a>2. IntelliJ IDEA 介绍</h3><p> IntelliJ IDEA 主要用于支持 Java、Scala、Groovy 等语言的开发工<br>具，同时具备支持目前主流的技术和框架，擅长于企业应用、移动应用和 Web 应用的开发。</p><h3 id="3-IDEA-的主要功能介绍"><a href="#3-IDEA-的主要功能介绍" class="headerlink" title="3.IDEA 的主要功能介绍"></a>3.IDEA 的主要功能介绍</h3><p>1.语言支持上：<br> <img src="/images/Screenshot 2020-12-10 165854.png"><br>2.其他支持：<br> <img src="/images/Screenshot 2020-12-10 165908.png"></p><h3 id="4-官方使用文档"><a href="#4-官方使用文档" class="headerlink" title="4.官方使用文档"></a>4.官方使用文档</h3><p>官网提供的详细使用文档：<br><a href="https://www.jetbrains.com/help/idea/meet-intellij-idea.html">https://www.jetbrains.com/help/idea/meet-intellij-idea.html</a></p><h1 id="二、windows-下安装过程"><a href="#二、windows-下安装过程" class="headerlink" title="二、windows 下安装过程"></a>二、windows 下安装过程</h1><h3 id="1-Java开发环境搭建（Java-SE-Development-Kit-8）"><a href="#1-Java开发环境搭建（Java-SE-Development-Kit-8）" class="headerlink" title="1.Java开发环境搭建（Java SE Development Kit 8）"></a>1.Java开发环境搭建（Java SE Development Kit 8）</h3><h4 id="1-卸载jdk8"><a href="#1-卸载jdk8" class="headerlink" title="1.卸载jdk8"></a>1.卸载jdk8</h4><p>1.删除Java的安装目录<br>2.删除环境变量</p><h4 id="2-安装jdk8"><a href="#2-安装jdk8" class="headerlink" title="2.安装jdk8"></a>2.安装jdk8</h4><p>官网下载<br><a href="http://www.oracle.com/">http://www.oracle.com</a><br> <img src="/images/Screenshot 2020-12-10 172753.png"></p><p>根据引导界面进行安装，记住安装路径配置环境变量<br> <img src="/images/Screenshot 2020-12-11 110537.png"><br>终端中输入查看是否安装好<br> <img src="/images/Screenshot 2020-12-11 110642.png"><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin        放可执行程序容器，执行文件和启动参数等</span><br><span class="line">&#x2F;include    C语言的头文件jdk是用C和C++写的</span><br><span class="line">&#x2F;jre        java运行环境</span><br><span class="line">&#x2F;lib        java的类库文件</span><br><span class="line">&#x2F;src        资源文件类文件</span><br></pre></td></tr></table></figure></p><h3 id="2-Java开发工具安装"><a href="#2-Java开发工具安装" class="headerlink" title="2.Java开发工具安装"></a>2.Java开发工具安装</h3><h4 id="1-卸载过程"><a href="#1-卸载过程" class="headerlink" title="1.卸载过程"></a>1.卸载过程</h4><h4 id="2-安装过程"><a href="#2-安装过程" class="headerlink" title="2.安装过程"></a>2.安装过程</h4><p>官网下载根据引导界面进行安装</p><h4 id="3-查看安装目录结构"><a href="#3-查看安装目录结构" class="headerlink" title="3.查看安装目录结构"></a>3.查看安装目录结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls -X</span><br><span class="line">bin&#x2F; #容器，执行文件和启动参数等</span><br><span class="line">jre64&#x2F; #64 位java 运行环境</span><br><span class="line">lib&#x2F; #idea 依赖的类库</span><br><span class="line">license&#x2F; #各个插件许可</span><br><span class="line">plugins&#x2F; #插件</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>其中：bin 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls .&#x2F;bin | grep &#39;idea&#39;</span><br><span class="line">idea.exe #32位IDEA启动文件</span><br><span class="line">idea64.exe.vmoptions #64位IDEA的VM配置文件</span><br><span class="line">idea.properties #IDEA属性配置文件</span><br><span class="line">idea64.exe #64位IDEA启动文件</span><br><span class="line">idea64.exe.vmoptions #64位IDEA的VM配置文件</span><br></pre></td></tr></table></figure><h4 id="4-config和system目录"><a href="#4-config和system目录" class="headerlink" title="4.config和system目录"></a>4.config和system目录</h4><p>更改目录<br> <img src="/images/Screenshot 2020-12-12 091244.png"></p><h5 id="config-目录是-IntelliJ-IDEA-个性化化配置目录，或者说是整个-IDE-设置目录。"><a href="#config-目录是-IntelliJ-IDEA-个性化化配置目录，或者说是整个-IDE-设置目录。" class="headerlink" title="config 目录是 IntelliJ IDEA 个性化化配置目录，或者说是整个 IDE 设置目录。"></a>config 目录是 IntelliJ IDEA 个性化化配置目录，或者说是整个 IDE 设置目录。</h5><p>此目录可看成是最重要的目录，没有之一，如果你还记得安装篇的介绍的时候，<br>安装新版本的 IntelliJ IDEA 会自动扫描硬盘上的旧配置目录，指的就是该目录。<br>这个目录主要记录了：IDE 主要配置功能、自定义的代码模板、自定义的文件<br>模板、自定义的快捷键、Project 的 tasks 记录等等个性化的设置。</p><h5 id="system-目录是-IntelliJ-IDEA-系统文件目录"><a href="#system-目录是-IntelliJ-IDEA-系统文件目录" class="headerlink" title="system 目录是 IntelliJ IDEA 系统文件目录"></a>system 目录是 IntelliJ IDEA 系统文件目录</h5><p>是 IntelliJ IDEA 与开发项目一个桥梁目录，里面主要有：缓存、索引、容器文件输出等等，虽然不是最重要目录，但也是最不可或缺的目录之一。</p><h1 id="三-创建-Java-工程"><a href="#三-创建-Java-工程" class="headerlink" title="三 创建 Java 工程"></a>三 创建 Java 工程</h1><h3 id="1-创建-Java-工程"><a href="#1-创建-Java-工程" class="headerlink" title="1.创建 Java 工程"></a>1.创建 Java 工程</h3><img src="/images/Screenshot 2020-12-12 093003.png"> Create New Project:创建一个新的工程<p> Open or Import:导入一个现有的工程</p><p> Check out from Version Control:可以通过服务器上的项目地址 check out Github上面项目或其他 Git 托管服务器上的项目</p><h3 id="2-显示常见的视图"><a href="#2-显示常见的视图" class="headerlink" title="2.显示常见的视图"></a>2.显示常见的视图</h3><img src="/images/Screenshot 2020-12-12 093449.png"><h3 id="3-工程界面展示"><a href="#3-工程界面展示" class="headerlink" title="3.工程界面展示"></a>3.工程界面展示</h3><img src="/images/win.png">工程下的 src 类似于 Eclipse 下的 src 目录，用于存放代码。  工程下的.idea 和 project01.iml 文件都是 IDEA 工程特有的。类似于 Eclipse 工程下的.settings、.classpath、.project 等。<h3 id="4-创建-package-和-class"><a href="#4-创建-package-和-class" class="headerlink" title="4.创建 package 和 class"></a>4.创建 package 和 class</h3><img src="/images/Screenshot 2020-12-12 095238.png">接着在 src 目录下创建一个class或者先创建package再创建class：<img src="/images/Screenshot 2020-12-12 095156.png">不管是创建 class，还是 interface，还是 annotation，都是选择 new – java class，IntelliJ IDEA 的安装、配置与使用然后在下拉框中选择创建的结构的类型。<p>说明：在 IDEA 里要说的是，写完代码，不用点击保存。IDEA 会自动保存代码。</p><h3 id="5-创建模块-Module"><a href="#5-创建模块-Module" class="headerlink" title="5. 创建模块(Module)"></a>5. 创建模块(Module)</h3><h4 id="1-在-Eclipse-中我们有-Workspace（工作空间）和-Project（工程）的概念，在-IDEA中只有-Project（工程）和-Module（模块）的概念。这里的对应关系为："><a href="#1-在-Eclipse-中我们有-Workspace（工作空间）和-Project（工程）的概念，在-IDEA中只有-Project（工程）和-Module（模块）的概念。这里的对应关系为：" class="headerlink" title="1.在 Eclipse 中我们有 Workspace（工作空间）和 Project（工程）的概念，在 IDEA中只有 Project（工程）和 Module（模块）的概念。这里的对应关系为："></a>1.在 Eclipse 中我们有 Workspace（工作空间）和 Project（工程）的概念，在 IDEA中只有 Project（工程）和 Module（模块）的概念。这里的对应关系为：</h4> <img src="/images/Screenshot 2020-12-12 102412.png"><h4 id="2-一个-Project-打开一个-Window-窗口"><a href="#2-一个-Project-打开一个-Window-窗口" class="headerlink" title="2.一个 Project 打开一个 Window 窗口"></a>2.一个 Project 打开一个 Window 窗口</h4><p>从 Eclipse 转过来的人总是下意识地要在同一个窗口管理 n 个项目，这在<br>IntelliJ IDEA 是无法做到的。IntelliJ IDEA 提供的解决方案是打开多个项目实例，<br>即打开多个项目窗口。即：一个 Project 打开一个 Window 窗口。</p><h4 id="3-在-IntelliJ-IDEA-中-Project-是最顶级的级别，次级别是-Module。"><a href="#3-在-IntelliJ-IDEA-中-Project-是最顶级的级别，次级别是-Module。" class="headerlink" title="3.在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。"></a>3.在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。</h4><p>一个 Project 可以有多个 Module。目前主流的大型项目都是分布式部署的，结构都是类似这<br>种多 Module 结构。<br><img src="/images/www.png"><br>这类项目一般是这样划分的，比如：core Module、web Module、plugin Module、<br>solr Module 等等，模块之间彼此可以相互依赖。通过这些 Module 的命名也可<br>以看出，他们之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的<br>业务关系的。举例：<br><img src="/images/wins.png"></p><h4 id="4-创建-Module"><a href="#4-创建-Module" class="headerlink" title="4.创建 Module"></a>4.创建 Module</h4><p>分布式版本控制 相比较于多 Module 项目，小项目就无需搞得这么复杂。只有一个 Module 的结构 IntelliJ IDEA 也是支持的，并且 IntelliJ IDEA 创建项目的时候，默认就是单Module 的结构的。<br><img src="/images/Screenshot 2020-12-12 104229.png" ><br>之后，我们可以在 Module 的 src 里写代码，此时 Project 工程下的 src 就没什么<br>用了。</p><h3 id="六-删除模块-Module"><a href="#六-删除模块-Module" class="headerlink" title="六 删除模块(Module)"></a>六 删除模块(Module)</h3><img src="/images/ying.png" ><img src="/images/dsuahi.png" ><img src="/images/dvasdvs.png" >此时的删除，会从硬盘上将此 module 删除掉。只用当它不再是以一个模板输出是才可以删除。<h3 id="七-查看项目配置"><a href="#七-查看项目配置" class="headerlink" title="七.查看项目配置"></a>七.查看项目配置</h3><img src="/images/shdvuhs.png" >进入项目结构：<img src="/images/saidjvosdj.png" >**java: 无效的源发行版**出现该问题的原因是项目Project当中的jdk与电脑当中的jdk版本不一致造成的。首先在终端中输入 Java -version查看jdk版本第一步:打开Project Structure项目结构如上图第二步：修改Project的SDK版本修改Module模块的Language Level修改Module模块中的Module SDK<p>3.找到Java Complier，修改byte code version，使其版本与sdk版本保持一致</p><img src="/images/2020081114523523.png" ><h1 id="四、常用配置"><a href="#四、常用配置" class="headerlink" title="四、常用配置"></a>四、常用配置</h1><h3 id="进入设置界面：目录结构如下："><a href="#进入设置界面：目录结构如下：" class="headerlink" title="进入设置界面：目录结构如下："></a>进入设置界面：目录结构如下：</h3><img src="/images/che.png" ><h4 id="1-Appearance-amp-Behavior"><a href="#1-Appearance-amp-Behavior" class="headerlink" title="1.Appearance &amp; Behavior"></a>1.Appearance &amp; Behavior</h4><h5 id="1-1-设置主题"><a href="#1-1-设置主题" class="headerlink" title="1.1 设置主题"></a>1.1 设置主题</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、IntelliJ-IDEA-介绍&quot;&gt;&lt;a href=&quot;#一、IntelliJ-IDEA-介绍&quot; class=&quot;headerlink&quot; title=&quot;一、IntelliJ IDEA 介绍&quot;&gt;&lt;/a&gt;一、IntelliJ IDEA 介绍&lt;/h1&gt;&lt;h3 id=&quot;1</summary>
      
    
    
    
    
    <category term="tools" scheme="http://example.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>text</title>
    <link href="http://example.com/2020/12/05/text/"/>
    <id>http://example.com/2020/12/05/text/</id>
    <published>2020-12-05T03:15:21.000Z</published>
    <updated>2020-12-10T09:36:24.889Z</updated>
    
    <content type="html"><![CDATA[<p>这是我第一个的博客文章主要是熟悉markdown语法以及前端三剑客Html css js和站点配置文件和主题配置文件的配置还有一些相关的图片和视频的插入相关知识等相关基础语法的使用<br><img src="/images/WIN_20201205_10_07_18_Pro.jpg" alt="今天上午一个人在实验室"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是我第一个的博客文章主要是熟悉markdown语法以及前端三剑客Html css js和站点配置文件和主题配置文件的配置还有一些相关的图片和视频的插入相关知识等相关基础语法的使用&lt;br&gt;&lt;img src=&quot;/images/WIN_20201205_10_07_18_Pro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://example.com/2020/12/05/git/"/>
    <id>http://example.com/2020/12/05/git/</id>
    <published>2020-12-05T02:38:10.000Z</published>
    <updated>2021-03-09T06:41:59.848Z</updated>
    
    <content type="html"><![CDATA[<p>这篇blog是根据廖雪峰和狂神说以及尚硅谷GitHub教程关于git<br><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000">https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000</a><br><a href="https://www.kuangstudy.com/">https://www.kuangstudy.com/</a><br><a href="https://www.bilibili.com/video/BV1pW411A7a5?from=search&amp;seid=1821377375998091062">https://www.bilibili.com/video/BV1pW411A7a5?from=search&amp;seid=1821377375998091062</a></p><h1 id="一-版本控制"><a href="#一-版本控制" class="headerlink" title="一.版本控制"></a>一.版本控制</h1><h4 id="什么是本版控制"><a href="#什么是本版控制" class="headerlink" title="什么是本版控制"></a>什么是本版控制</h4><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。简单说就是用于管理多人协同开发项目的技术。<strong>版本迭代</strong><br>1.实现跨区域多人协同开发<br>2.追踪和记载一个或者多个文件的历史记录<br>3.组织和保护你的源代码和文档<br>4.统计工作量<br>5.并行开发、提高开发效率<br>6.跟踪记录整个软件的开发过程<br>7.减轻开发人员的负担，节省时间，同时降低人为错误</p><h2 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h2><p>Git<br>SVN（Subversion）<br>CVS（Concurrent Versions System）<br>VSS（Micorosoft Visual SourceSafe）<br>TFS（Team Foundation Server）<br>Visual Studio Online</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><h4 id="1、本地版本控制"><a href="#1、本地版本控制" class="headerlink" title="1、本地版本控制"></a>1、本地版本控制</h4><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。<br><img src="/images/640.webp"></p><h4 id="2、集中版本控制-SVN"><a href="#2、集中版本控制-SVN" class="headerlink" title="2、集中版本控制  SVN"></a>2、集中版本控制  SVN</h4><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改.所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS<br><img src="/images/640.png"></p><h4 id="3-分布式版本控制-Git"><a href="#3-分布式版本控制-Git" class="headerlink" title="3.分布式版本控制     Git"></a>3.分布式版本控制     Git</h4><p>每个人都拥有全部的代码！安全隐患<br>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。<br><img src="/images/640.jfif"></p><h4 id="4-Git与SVN的主要区别"><a href="#4-Git与SVN的主要区别" class="headerlink" title="4.Git与SVN的主要区别"></a>4.Git与SVN的主要区别</h4><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。<br>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><h1 id="二-Git环境配置"><a href="#二-Git环境配置" class="headerlink" title="二.Git环境配置"></a>二.Git环境配置</h1><h4 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h4><p>下载对应的版本即可安装！<br>安装：无脑下一步即可！安装完毕就可以使用了！<br>配置环境变量</p><h4 id="2-启动git"><a href="#2-启动git" class="headerlink" title="2.启动git"></a>2.启动git</h4><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！<br>Git Bash：Linux风格的命令行，查看Linux博客学习使用<br>Git CMD：Windows风格的命令行<br>Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p><h4 id="3-Git配置"><a href="#3-Git配置" class="headerlink" title="3.Git配置"></a>3.Git配置</h4><p>所有的配置文件，其实都保存在本地！<br>E:\Gitcode本地保存Git代码</p><h5 id="Git相关的配置文件："><a href="#Git相关的配置文件：" class="headerlink" title="Git相关的配置文件："></a>Git相关的配置文件：</h5><p>1）D:\tools\Git\etc\gitconfig<br>Git 安装目录下的 gitconfig     –system 系统级</p><p>2）C:\Users\陈龙\ .gitconfig<br> 只适用于当前登录用户的配置  –global 全局</p><h5 id="查看系统config"><a href="#查看系统config" class="headerlink" title="查看系统config"></a>查看系统config</h5><p><code>git config --system --list</code></p><h5 id="查看当前用户（global）配置"><a href="#查看当前用户（global）配置" class="headerlink" title="查看当前用户（global）配置"></a>查看当前用户（global）配置</h5><p><code>git config --global  --list</code><br>#####设置用户名与邮箱（用户标识，必要）<br>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;jinzhitx&quot;  #名称</span><br><span class="line">git config --global user.email 208468793@qq.com   #邮箱</span><br></pre></td></tr></table></figure><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><h1 id="三-Git基本理论和项目文件操作"><a href="#三-Git基本理论和项目文件操作" class="headerlink" title="三.Git基本理论和项目文件操作"></a>三.Git基本理论和项目文件操作</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h4 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h4><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：<br><img src="/images/640 (1).png"><br>Workspace：工作区，就是你平时存放项目代码的地方</p><p>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</p><p>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p><p>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p><h5 id="本地的三个区域确切的说应该是git仓库中HEAD指向的版本："><a href="#本地的三个区域确切的说应该是git仓库中HEAD指向的版本：" class="headerlink" title="本地的三个区域确切的说应该是git仓库中HEAD指向的版本："></a>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</h5><img src="/images/640 (1).webp" ><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)<br><img src="/images/640 (2).webp" ></p><h2 id="Git项目的搭建"><a href="#Git项目的搭建" class="headerlink" title="Git项目的搭建"></a>Git项目的搭建</h2><h4 id="创建工作目录与常用指令"><a href="#创建工作目录与常用指令" class="headerlink" title="创建工作目录与常用指令"></a>创建工作目录与常用指令</h4><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：<br><img src="/images/640 (2).png" ></p><h4 id="本地仓库的搭建"><a href="#本地仓库的搭建" class="headerlink" title="本地仓库的搭建"></a>本地仓库的搭建</h4><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><h5 id="1、创建全新的仓库，需要用GIT管理的项目的根目录执行"><a href="#1、创建全新的仓库，需要用GIT管理的项目的根目录执行" class="headerlink" title="1、创建全新的仓库，需要用GIT管理的项目的根目录执行"></a>1、创建全新的仓库，需要用GIT管理的项目的根目录执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><h5 id="2-克隆远程仓库"><a href="#2-克隆远程仓库" class="headerlink" title="2.克隆远程仓库"></a>2.克隆远程仓库</h5><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">$ git clone [url]  # https:&#x2F;&#x2F;gitee.com&#x2F;kuangstudy&#x2F;openclass.git</span><br></pre></td></tr></table></figure><h2 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h2><h4 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h4><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。<br>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p><p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p><p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</p><p>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</p><h4 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h4><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查看指定文件状态</span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line"># 查看所有文件状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"># 添加所有文件到暂存区</span><br><span class="line">git add . </span><br><span class="line"></span><br><span class="line"># 提交暂存区中的内容到本地仓库 -m 提交信息</span><br><span class="line">git commit -m &quot;消息内容&quot;    </span><br></pre></td></tr></table></figure><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>1.在主目录下建立”.gitignore”文件，此文件有如下规则：</p><p>2.忽略文件中的空行或以井号（#）开始的行将会被忽略。</p><p>3.可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</p><p>4.如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</p><p>5.如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</p><p>6.如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">&#x2F;temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build&#x2F;       #忽略build&#x2F;目录下的所有文件</span><br><span class="line">doc&#x2F;*.txt    #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</span><br></pre></td></tr></table></figure><h1 id="四-Github常用命令"><a href="#四-Github常用命令" class="headerlink" title="四.Github常用命令"></a>四.Github常用命令</h1><pre><code>https://mubu.com/app/edit/home/7bNduJGbRlL#m</code></pre><img src="/images/Screenshot 2021-03-06 203239.png"><h1 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h1><p>由于notepad++开发者带有强烈的政治色彩所以我使用功能更加强大的Editplus（默认编码为UTF-8）虽然Editplus收费但仔细上网查询有免费的密钥。同时Editplus（.bak保存临事备份文件）也是本机的默认文本编辑器因为Microsoft开发记事本的团队在每个文件开头添加了0xefbbbf（十六进制）的字符行为来保存UTF-8编码的文件。</p><p>Git命令必须在Git仓库目录内执行（git init创建版本库除外），在仓库目录外执行是没有意义的。</p><p>添加文件到Git仓库，分两步：<br>1.使用命令git add <file>，注意，可反复多次使用，添加多个文件；<br>2.使用命令git commit -m <message>，完成。</p><p>git status命令可以让我们时刻掌握<strong>仓库</strong>当前的状态，git status告诉你有文件被修改过，用git diff (HEAD工作区和版本库里面最新版本的区别：)可以查看修改内容（工作区和暂存区）。<br>git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上(–pretty=oneline)参数，若果使用参数的话可以看到一大串类似1094adb…的是commit id (版本号)，和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</p><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><p>git log命令查看版本控制系统历史记录，命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。<br><img src="/images/Screenshot 2021-03-09 120436.png"><br>如果把readme.txt回退到上一个版本，也就是add distributed的那个版本，首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>查看文本内容，被还原了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br></pre></td></tr></table></figure><p>git log再看看现在版本库的状态：<br><img src="/images/Screenshot 2021-03-09 121213.png"><br>最新的那个版本append GPL已经看不到了，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb…，于是就可以指定回到未来的某个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br></pre></td></tr></table></figure><p>如果找不到commit id ,这个命令记录了每一次git commit文件的id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</p><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p><h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><img src="/images/Screenshot 2021-03-09 123035.png">工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库，当我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。<h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>Git的核心思想是跟踪修改<br>每次修改，如果不用git add到暂存区，那就不会加入到commit中。<br>git checkout – file可以丢弃工作区的修改<br>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p><p>从暂存区恢复工作区，git resotre –worktree readme.txt<br>从master恢复暂存区 git restore –staged readme.txt<br>从master同时恢复工作区和暂存区git restore –source=HEAD –staged –worktree readme.txt<br>原来的git checkout 可以使用 git restore 代替</p><p>git reset HEAD 可以使用 git restore –staged 代替<br>最新版的git提示都已经更换成了restore</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。<br>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。<br>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h1 id="本地库关联远程库"><a href="#本地库关联远程库" class="headerlink" title="本地库关联远程库"></a>本地库关联远程库</h1><p>首先本地执行切换C盘符cat ~/.ssh/id_rsa.pub查看publickey，然后在你的GitHub上添加这个公钥。<br>再次在GitHub上创建库根据提示关联本地就行。<br>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇blog是根据廖雪峰和狂神说以及尚硅谷GitHub教程关于git&lt;br&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000&quot;&gt;https://www.liaoxuefeng.</summary>
      
    
    
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
</feed>
